<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="Some time ago I was using Logic Pro to record some of my music and I needed a way to start and stop the recording from an iPhone, so I found about Logic Remote and was quite happy with it.After the se">
<meta property="og:type" content="article">
<meta property="og:title" content="Reverse Engineering the Apple MultiPeer Connectivity Framework">
<meta property="og:url" content="https://www.evilsocket.net/2022/10/20/Reverse-Engineering-the-Apple-MultiPeer-Connectivity-Framework/index.html">
<meta property="og:site_name" content="evilsocket">
<meta property="og:description" content="Some time ago I was using Logic Pro to record some of my music and I needed a way to start and stop the recording from an iPhone, so I found about Logic Remote and was quite happy with it.After the se">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://www.evilsocket.net/images/2022/cleartext.png">
<meta property="og:image" content="https://www.evilsocket.net/images/2022/lsof.png">
<meta property="og:image" content="https://www.evilsocket.net/images/2022/crash.png">
<meta property="og:image" content="https://www.evilsocket.net/images/2022/mdns_server.png">
<meta property="og:image" content="https://www.evilsocket.net/images/2022/mdns_client.png">
<meta property="og:image" content="https://www.evilsocket.net/images/2022/hexdata.png">
<meta property="og:image" content="https://www.evilsocket.net/images/2022/client_invite.png">
<meta property="og:image" content="https://www.evilsocket.net/images/2022/server_prompt.png">
<meta property="og:image" content="https://www.evilsocket.net/images/2015/Jan/major-facepalm.jpg">
<meta property="og:image" content="https://www.evilsocket.net/images/2022/ospf.png">
<meta property="article:published_time" content="2022-10-20T11:05:13.000Z">
<meta property="article:modified_time" content="2022-10-22T16:24:11.125Z">
<meta property="article:author" content="Simone Margaritelli">
<meta property="article:tag" content="network">
<meta property="article:tag" content="re">
<meta property="article:tag" content="apple">
<meta property="article:tag" content="reverse engineering">
<meta property="article:tag" content="multipeerconnectivity">
<meta property="article:tag" content="mpc framework">
<meta property="article:tag" content="framework">
<meta property="article:tag" content="multipeer">
<meta property="article:tag" content="wireshark">
<meta property="article:tag" content="network packets">
<meta property="article:tag" content="network protocol">
<meta property="article:tag" content="tcp">
<meta property="article:tag" content="stun">
<meta property="article:tag" content="facetime">
<meta property="article:tag" content="mcpeer">
<meta property="article:tag" content="mcpeerid">
<meta property="article:tag" content="mdns">
<meta property="article:tag" content="ospf">
<meta property="article:tag" content="ice">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.evilsocket.net/images/2022/cleartext.png">
    
    
        
          
              <link rel="shortcut icon" href="/images/favicon.ico">
          
        
        
          
            <link rel="icon" type="image/png" href="/images/favicon.ico" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico">
          
        
    
    <!-- title -->
    <title>Reverse Engineering the Apple MultiPeer Connectivity Framework</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
      
<link rel="stylesheet" href="/css/rtl.css">

    
    <!-- rss -->
    
    
      <link rel="alternate" href="/atom.xml" title="evilsocket" type="application/atom+xml" />
    
<meta name="generator" content="Hexo 5.4.2"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">~/</a></li>
         
          <li><a href="/atom.xml">rss</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/2023/11/02/Enumerate-Bruteforce-Attack-All-The-Things-Presenting-Legba/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/2022/08/15/Process-behaviour-anomaly-detection-using-eBPF-and-unsupervised-learning-Autoencoders/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://www.evilsocket.net/2022/10/20/Reverse-Engineering-the-Apple-MultiPeer-Connectivity-Framework/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://www.evilsocket.net/2022/10/20/Reverse-Engineering-the-Apple-MultiPeer-Connectivity-Framework/&text=Reverse Engineering the Apple MultiPeer Connectivity Framework"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://www.evilsocket.net/2022/10/20/Reverse-Engineering-the-Apple-MultiPeer-Connectivity-Framework/&title=Reverse Engineering the Apple MultiPeer Connectivity Framework"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://www.evilsocket.net/2022/10/20/Reverse-Engineering-the-Apple-MultiPeer-Connectivity-Framework/&is_video=false&description=Reverse Engineering the Apple MultiPeer Connectivity Framework"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Reverse Engineering the Apple MultiPeer Connectivity Framework&body=Check out this article: https://www.evilsocket.net/2022/10/20/Reverse-Engineering-the-Apple-MultiPeer-Connectivity-Framework/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://www.evilsocket.net/2022/10/20/Reverse-Engineering-the-Apple-MultiPeer-Connectivity-Framework/&title=Reverse Engineering the Apple MultiPeer Connectivity Framework"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://www.evilsocket.net/2022/10/20/Reverse-Engineering-the-Apple-MultiPeer-Connectivity-Framework/&title=Reverse Engineering the Apple MultiPeer Connectivity Framework"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://www.evilsocket.net/2022/10/20/Reverse-Engineering-the-Apple-MultiPeer-Connectivity-Framework/&title=Reverse Engineering the Apple MultiPeer Connectivity Framework"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://www.evilsocket.net/2022/10/20/Reverse-Engineering-the-Apple-MultiPeer-Connectivity-Framework/&title=Reverse Engineering the Apple MultiPeer Connectivity Framework"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://www.evilsocket.net/2022/10/20/Reverse-Engineering-the-Apple-MultiPeer-Connectivity-Framework/&name=Reverse Engineering the Apple MultiPeer Connectivity Framework&description=&lt;p&gt;Some time ago I was using &lt;a href=&#34;https://www.apple.com/it/logic-pro/&#34;&gt;Logic Pro&lt;/a&gt; to record some of my music and I needed a way to start and stop the recording from an iPhone, so I found about &lt;a href=&#34;https://apps.apple.com/it/app/logic-remote/id638394624&#34;&gt;Logic Remote&lt;/a&gt; and was quite happy with it.&lt;br&gt;After the session, the hacker in me became curious about how the tools were communicating with each other, so I quickly started Wireshark while establishing a connection and saw something that tickled my curiosity even more: some of the data, such as the client and server names, were transmitted in cleartext on what it seemed a custom (and as typical of Apple, undocumented) TCP protocol (&lt;strong&gt;‚Äústevie‚Äù&lt;/strong&gt; being the hostname of my Mac):&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/2022/cleartext.png&#34; alt=&#34;cleartext packets&#34;&gt;&lt;/p&gt;
&lt;p&gt;Using &lt;a href=&#34;https://ss64.com/osx/lsof.html&#34;&gt;lsof&lt;/a&gt; confirmed that this was indeed the communication between the client phone and Logic listening on port 56076:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/2022/lsof.png&#34; alt=&#34;lsof&#34;&gt;&lt;/p&gt;
&lt;p&gt;Initially I tought this was just some Logic Pro specific protocol and very lazily started looking into it, without much success mostly due to lack of motivation given the very limited scope of the research. After a while I &lt;a href=&#34;https://twitter.com/evilsocket/status/1568310905640722433&#34;&gt;tweeted&lt;/a&gt; asking if anyone had ever seen anything like it. &lt;a href=&#34;https://twitter.com/isComputerOn/status/1568344165175508992&#34;&gt;@isComputerOn pointed out&lt;/a&gt; that this looked a lot like a protocol that has been partially reversed and presented by &lt;a href=&#34;https://twitter.com/nabla_c0d3&#34;&gt;Alban Diquet&lt;/a&gt; back in 2014. Unfortunately, however brilliant, this research covers the protocol at a very high level and doesn‚Äôt really document the packets, their fields and how to establish a connection from anything but a client using the Apple framework. However, this helped me a lot in two ways: first it helped me realize this was not just Logic Pro specific, but that it was part of the &lt;a href=&#34;https://developer.apple.com/documentation/multipeerconnectivity&#34;&gt;Multipeer Connectivity Framework&lt;/a&gt;, and gave me a few hints about the general logic of the protocol itself.&lt;/p&gt;
&lt;p&gt;With renewed curiosity and motivation then I jumped into this rabbit hole and managed to reverse engineer all network packets. This allowed me to write a &lt;a href=&#34;https://github.com/evilsocket/mpcfw&#34;&gt;Python proof of concept client&lt;/a&gt; that automatically discovers any MPC servers, initializes the connection and succesfully exchanges application specific data packets.&lt;/p&gt;
&lt;p&gt;Moreover, while sending crafted packets and attempting all sorts of things, &lt;strong&gt;I‚Äôve discovered several vulnerabilities in the Apple custom made parsers&lt;/strong&gt;. I will &lt;strong&gt;not&lt;/strong&gt; discuss them here (exception made for the session spoofing) but at the same time I‚Äôm not interested in reporting them to Apple, I‚Äôve heard way too many negative stories about their disclosure program and in general how they mistreat researchers.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/2022/crash.png&#34; alt=&#34;crash&#34;&gt;&lt;/p&gt;
&lt;p&gt;Let‚Äôs see how this whole thing works! :)&lt;/p&gt;"><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#MultipeerConnectivity-Framework"><span class="toc-number">1.</span> <span class="toc-text">MultipeerConnectivity Framework</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Discovery-Phase-Multicast-DNS"><span class="toc-number">2.</span> <span class="toc-text">Discovery Phase: Multicast DNS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#How-a-PeerID-is-made"><span class="toc-number">3.</span> <span class="toc-text">How a PeerID is made</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Handshake-Phase-Hellos-and-Acks"><span class="toc-number">4.</span> <span class="toc-text">Handshake Phase: Hellos and Acks</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Authorization-Phase-Spoofable-Invites-and-BPlist-inside-BPlist-inside-TCP"><span class="toc-number">5.</span> <span class="toc-text">Authorization Phase: Spoofable Invites and BPlist inside BPlist inside TCP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Data-Exchange-Phase"><span class="toc-number">6.</span> <span class="toc-text">Data Exchange Phase</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#STUN-a-la-Facetime"><span class="toc-number">7.</span> <span class="toc-text">STUN a la Facetime</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Brief-note-on-OSPF"><span class="toc-number">8.</span> <span class="toc-text">Brief note on OSPF</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Conclusion"><span class="toc-number">9.</span> <span class="toc-text">Conclusion</span></a></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index my4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline" style="text-transform: uppercase;">
        Reverse Engineering the Apple MultiPeer Connectivity Framework
    </h1>



    <div class="meta">
      
    <div class="postdate">
        <time datetime="2022-10-20T11:05:13.000Z" itemprop="datePublished">2022-10-20</time>
    </div>


      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link-link" href="/tags/apple/" rel="tag">apple</a>, <a class="tag-link-link" href="/tags/facetime/" rel="tag">facetime</a>, <a class="tag-link-link" href="/tags/framework/" rel="tag">framework</a>, <a class="tag-link-link" href="/tags/ice/" rel="tag">ice</a>, <a class="tag-link-link" href="/tags/mcpeer/" rel="tag">mcpeer</a>, <a class="tag-link-link" href="/tags/mcpeerid/" rel="tag">mcpeerid</a>, <a class="tag-link-link" href="/tags/mdns/" rel="tag">mdns</a>, <a class="tag-link-link" href="/tags/mpc-framework/" rel="tag">mpc framework</a>, <a class="tag-link-link" href="/tags/multipeer/" rel="tag">multipeer</a>, <a class="tag-link-link" href="/tags/multipeerconnectivity/" rel="tag">multipeerconnectivity</a>, <a class="tag-link-link" href="/tags/network/" rel="tag">network</a>, <a class="tag-link-link" href="/tags/network-packets/" rel="tag">network packets</a>, <a class="tag-link-link" href="/tags/network-protocol/" rel="tag">network protocol</a>, <a class="tag-link-link" href="/tags/ospf/" rel="tag">ospf</a>, <a class="tag-link-link" href="/tags/re/" rel="tag">re</a>, <a class="tag-link-link" href="/tags/reverse-engineering/" rel="tag">reverse engineering</a>, <a class="tag-link-link" href="/tags/stun/" rel="tag">stun</a>, <a class="tag-link-link" href="/tags/tcp/" rel="tag">tcp</a>, <a class="tag-link-link" href="/tags/wireshark/" rel="tag">wireshark</a>
    </div>


    </div>

    <div class="addthis_sharing_toolbox"></div>
  </header>

    <br/>
  

  <div class="content" itemprop="articleBody">
    <p>Some time ago I was using <a target="_blank" rel="noopener" href="https://www.apple.com/it/logic-pro/">Logic Pro</a> to record some of my music and I needed a way to start and stop the recording from an iPhone, so I found about <a target="_blank" rel="noopener" href="https://apps.apple.com/it/app/logic-remote/id638394624">Logic Remote</a> and was quite happy with it.<br>After the session, the hacker in me became curious about how the tools were communicating with each other, so I quickly started Wireshark while establishing a connection and saw something that tickled my curiosity even more: some of the data, such as the client and server names, were transmitted in cleartext on what it seemed a custom (and as typical of Apple, undocumented) TCP protocol (<strong>‚Äústevie‚Äù</strong> being the hostname of my Mac):</p>
<p><img src="/images/2022/cleartext.png" alt="cleartext packets"></p>
<p>Using <a target="_blank" rel="noopener" href="https://ss64.com/osx/lsof.html">lsof</a> confirmed that this was indeed the communication between the client phone and Logic listening on port 56076:</p>
<p><img src="/images/2022/lsof.png" alt="lsof"></p>
<p>Initially I tought this was just some Logic Pro specific protocol and very lazily started looking into it, without much success mostly due to lack of motivation given the very limited scope of the research. After a while I <a target="_blank" rel="noopener" href="https://twitter.com/evilsocket/status/1568310905640722433">tweeted</a> asking if anyone had ever seen anything like it. <a target="_blank" rel="noopener" href="https://twitter.com/isComputerOn/status/1568344165175508992">@isComputerOn pointed out</a> that this looked a lot like a protocol that has been partially reversed and presented by <a target="_blank" rel="noopener" href="https://twitter.com/nabla_c0d3">Alban Diquet</a> back in 2014. Unfortunately, however brilliant, this research covers the protocol at a very high level and doesn‚Äôt really document the packets, their fields and how to establish a connection from anything but a client using the Apple framework. However, this helped me a lot in two ways: first it helped me realize this was not just Logic Pro specific, but that it was part of the <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/multipeerconnectivity">Multipeer Connectivity Framework</a>, and gave me a few hints about the general logic of the protocol itself.</p>
<p>With renewed curiosity and motivation then I jumped into this rabbit hole and managed to reverse engineer all network packets. This allowed me to write a <a target="_blank" rel="noopener" href="https://github.com/evilsocket/mpcfw">Python proof of concept client</a> that automatically discovers any MPC servers, initializes the connection and succesfully exchanges application specific data packets.</p>
<p>Moreover, while sending crafted packets and attempting all sorts of things, <strong>I‚Äôve discovered several vulnerabilities in the Apple custom made parsers</strong>. I will <strong>not</strong> discuss them here (exception made for the session spoofing) but at the same time I‚Äôm not interested in reporting them to Apple, I‚Äôve heard way too many negative stories about their disclosure program and in general how they mistreat researchers.</p>
<p><img src="/images/2022/crash.png" alt="crash"></p>
<p>Let‚Äôs see how this whole thing works! :)</p>
<span id="more"></span>

<h3 id="MultipeerConnectivity-Framework"><a href="#MultipeerConnectivity-Framework" class="headerlink" title="MultipeerConnectivity Framework"></a>MultipeerConnectivity Framework</h3><p>Apple‚Äôs <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/multipeerconnectivity">documentation</a> describes the framework like so:</p>
<blockquote>
<p>The Multipeer Connectivity framework supports the discovery of services provided by nearby devices and supports communicating with those services through message-based data, streaming data, and resources (such as files). In iOS, the framework uses infrastructure Wi-Fi networks, peer-to-peer Wi-Fi, and Bluetooth personal area networks for the underlying transport. In macOS and tvOS, it uses infrastructure Wi-Fi, peer-to-peer Wi-Fi, and Ethernet.</p>
</blockquote>
<p>The document mostly describes how they abstracted the protocol in several classes while being extremely vague about how the thing actually works at the packet level. In reality they mostly reused existing protocols such as MDNS and a customized STUN implementation (in Logic Pro specific case, this doesn‚Äôt always apply to apps using this framework), plus a custom TCP based protocol for which they heavily relied on custom (and extremely badly) written parsers.</p>
<h3 id="Discovery-Phase-Multicast-DNS"><a href="#Discovery-Phase-Multicast-DNS" class="headerlink" title="Discovery Phase: Multicast DNS"></a>Discovery Phase: Multicast DNS</h3><p>The very first thing that I‚Äôve noticed was that, despite the server port being randomized at each application startup, the client application never asked me for the server ip address nor tcp port. This was a strong indicator that something else was happening on the network before the TCP session was being established, as if the server (and possibly the client as well) broadcasted this information in such a way to be automatically discoverable, as also hinted by the wording used in the documentation. </p>
<p>My informed guess was <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Multicast_DNS">multicast DNS</a> as I‚Äôve seen this protocol being (ab)used a lot from Apple (<a target="_blank" rel="noopener" href="https://developer.apple.com/bonjour/">Bonjour</a> for instance), and Wireshark confirmed my guess. Both the server and the client are broadcasting their hostnames and peer identifiers (more on this later) on the network so that they can find each other without user interaction.</p>
<p>Here‚Äôs how the server advertisement looks like on <a target="_blank" rel="noopener" href="https://github.com/evilsocket/spycast">Spycast</a>:</p>
<p><img src="/images/2022/mdns_server.png" alt="mdns server"></p>
<p>We can see which TCP port is being used (57219), some application specific information in the text record and a weird string ‚Äú1tvdkfvihbru6‚Äù, the <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/multipeerconnectivity/mcpeerid">PeerID</a>.</p>
<p>At the same time, the client is broadcasting some information such as its hostname:</p>
<p><img src="/images/2022/mdns_client.png" alt="mdns client"></p>
<p>Keep in mind that all this data is visible by <strong>anyone</strong> on the same network, this is an important detail as we‚Äôll see shortly when I‚Äôll describe how the spoofing works.</p>
<h3 id="How-a-PeerID-is-made"><a href="#How-a-PeerID-is-made" class="headerlink" title="How a PeerID is made"></a>How a PeerID is made</h3><p>Before proceeding to the next part, let‚Äôs stop for a moment to see how a peer is identified in this protocol and what that ‚Äú1tvdkfvihbru6‚Äù string is.</p>
<p>Upon startup, each peer is represented by a <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/multipeerconnectivity/mcpeerid">MCPeerID</a> object. Long story short, a random 64bit integer is generated and converted to base36. </p>
<p>So that 1tvdkfvihbru6 in base36 is 8670129607084362000 in base 10. This number is used to uniquely identify the host during the session, regardless of the hostname itself and it‚Äôs present in various forms in most of the packets we‚Äôre about to see.</p>
<h3 id="Handshake-Phase-Hellos-and-Acks"><a href="#Handshake-Phase-Hellos-and-Acks" class="headerlink" title="Handshake Phase: Hellos and Acks"></a>Handshake Phase: Hellos and Acks</h3><p>After the client discovers the server peer via MDNS the connection is initiated to the TCP port indicated in the advertisement. This is when things started being complicated as the protocol is entirely custom and undocumented. </p>
<p>I needed to work my way from something like this:</p>
<p><img src="/images/2022/hexdata.png" alt="hex data"></p>
<p>To something <a target="_blank" rel="noopener" href="https://github.com/evilsocket/mpcfw/blob/main/mpc/tcp/messages.py">like this</a>.</p>
<p>For this task I‚Äôve performed dozens of tests such as:</p>
<ul>
<li>See if similar packets all started with the same signature bytes (they did).</li>
<li>See if by changing the hostname of the client, some other fields (possibly string length fields) changed reflecting the new length (they did).</li>
<li>See if there was any checksum going on by looking at 2 bytes and 4 bytes words that changed depending on the contents (there are).</li>
<li>See if packets were encapsulated with a common header plus a packet-specific payload, which length should be indicated in the header (it is).</li>
</ul>
<p>After a few days of testing I‚Äôve managed to understand that all the packets started with a header that looks like this:</p>
<ul>
<li>The first 2 bytes are the packet signature and determine the packet type (Hello, Ack, Invite, ‚Ä¶).</li>
<li>The next 4 bytes are a sequence number plus flags that are used only for some specific payloads.</li>
<li>We then have 2 bytes indicating the payload size after the header.</li>
<li>Following 4 bytes are the CRC32 of the whole packet (i wasn‚Äôt sure which checksum was, so <a target="_blank" rel="noopener" href="https://github.com/evilsocket/mpcfw/blob/main/mpc/utils.py#L13">I bruteforced it</a> :D)</li>
<li>The last 4 bytes of the header are unknown to me but they always seem to contain the same value.</li>
</ul>
<p>With this new knowledge I started looking into the payload of the first packets and identified how the connection handshake works:</p>
<ol>
<li>The client sends an <a target="_blank" rel="noopener" href="https://github.com/evilsocket/mpcfw/blob/main/mpc/tcp/messages.py#L172">Hello packet</a> made of the header and its <a target="_blank" rel="noopener" href="https://github.com/evilsocket/mpcfw/blob/main/mpc/tcp/messages.py#L66">PeerID</a>.</li>
<li>The server responds with an <a target="_blank" rel="noopener" href="https://github.com/evilsocket/mpcfw/blob/main/mpc/tcp/messages.py#L235">Ack packet</a>, made of just the header and no payload.</li>
<li>The server then sends its own Hello packet containing its PeerID (which seems redundant given its already broadcasted via MDNS, but whatever ‚Ä¶).</li>
<li>The client sends an Ack to the server Hello.</li>
<li>Finally the client sends an <a target="_blank" rel="noopener" href="https://github.com/evilsocket/mpcfw/blob/main/mpc/tcp/messages.py#L276">Accept packet</a> also only made of the header and no payload, indicating that the first part of the handshake is complete. The reason why the client is responsible for this and not the server will always remain a mystery to me :D</li>
</ol>
<p>You can find the implementation of this handshake process <a target="_blank" rel="noopener" href="https://github.com/evilsocket/mpcfw/blob/main/mpc/tcp/protocol.py#L29">here</a>.</p>
<h3 id="Authorization-Phase-Spoofable-Invites-and-BPlist-inside-BPlist-inside-TCP"><a href="#Authorization-Phase-Spoofable-Invites-and-BPlist-inside-BPlist-inside-TCP" class="headerlink" title="Authorization Phase: Spoofable Invites and BPlist inside BPlist inside TCP"></a>Authorization Phase: Spoofable Invites and BPlist inside BPlist inside TCP</h3><p>After this mutual introduction, the client will send an <a target="_blank" rel="noopener" href="https://github.com/evilsocket/mpcfw/blob/main/mpc/tcp/messages.py#L351">Invitation packet</a> and this is where things start getting covoluted (a la Apple): as we can see from the next picture, the Invite packet is made of the header plus a <a target="_blank" rel="noopener" href="https://medium.com/@karaiskc/understanding-apples-binary-property-list-format-281e6da00dbd">Binary Property List</a> as indicated by the ‚Äúbplist00‚Äù signature visible in cleartext in the packet:</p>
<p><img src="/images/2022/client_invite.png" alt="client invite"></p>
<p>A BPlist is basically a binary encoded XML document, in this case containing the following fields:</p>
<ul>
<li>MCNearbyServiceInviteContextKey: a bplist encoded (yes it‚Äôs a bplist inside a bplist ‚Ä¶) integer, always 0x2.</li>
<li>MCNearbyServiceInviteIDKey: an integer always set to 0x0.</li>
<li>MCNearbyServiceMessageIDKey: an integer message identifier, always 0x1 for invites.</li>
<li>MCNearbyServiceRecipientPeerIDKey: the message recipient (the server in this case) PeerID, encoded as described next.</li>
<li>MCNearbyServiceSenderPeerIDKey: the message sender (the client) PeerID.</li>
</ul>
<p>In the last two fields, the peer identifiers <a target="_blank" rel="noopener" href="https://github.com/evilsocket/mpcfw/blob/main/mpc/tcp/messages.py#L126">are encoded as</a>:</p>
<ul>
<li>8 bytes containing the numeric peer identifier, big endian.</li>
<li>1 byte containing the peer hostname length.</li>
<li>N bytes containing the unicode peer hostname.</li>
</ul>
<p>The server responds with an Ack and at this point two things can happen: if the client is unknown to the server, a prompt will be shown in order to let the user decide wether to authorize it or not:</p>
<p><img src="/images/2022/server_prompt.png" alt="server prompt"></p>
<p>However, if the client has been previously authorized, no prompt will be shown and the communication will silently continue to the next data exchange step.</p>
<p>At this point you might ask, how does the server store this authorization information? Is it some sort of session cookie? A more advanced cryptographic challenge mechanism? Black magic? Well my friends, often reality is way duller and dumber than what you might imagine :D</p>
<p><strong>They just don‚Äôt give a damn and keep a ‚Äústring peer_hostname -&gt; bool authorized‚Äù association ‚Ä¶ yes, you read that right, client authorization only relies on the (spoofable) client hostname, they don‚Äôt even care about the peer identifier number.</strong></p>
<p>Remember how all this information (and more) is being broadcasted in cleartext via MDNS for everyone to enjoy? Yep that‚Äôs right, an attacker can wait for a legit client to be authorized and then use its hostname (not on the network, just in the MCNearbyServiceSenderPeerIDKey field) in order to either hijack the legit session, or just create a new one of its own and completely bypass the authorization prompt üéâüéâüéâ</p>
<p><img src="/images/2015/Jan/major-facepalm.jpg" alt="facepalm"></p>
<p>Anyways ‚Ä¶ if authorized, the server will conclude this phase by sending an <a target="_blank" rel="noopener" href="https://github.com/evilsocket/mpcfw/blob/main/mpc/tcp/messages.py#L673">InviteResponse</a>, which is identical to the client Invite packet, back to the client. You can find the client invite logic <a target="_blank" rel="noopener" href="https://github.com/evilsocket/mpcfw/blob/main/mpc/tcp/protocol.py#L64">here</a> and the wait loop for the server response <a target="_blank" rel="noopener" href="https://github.com/evilsocket/mpcfw/blob/main/mpc/tcp/protocol.py#L79">here</a>.</p>
<p>Let‚Äôs continue.</p>
<h3 id="Data-Exchange-Phase"><a href="#Data-Exchange-Phase" class="headerlink" title="Data Exchange Phase"></a>Data Exchange Phase</h3><p>After the server accepted the invite, the client will proceed by sending a <a target="_blank" rel="noopener" href="https://github.com/evilsocket/mpcfw/blob/main/mpc/tcp/messages.py#L780">ClientData packet</a>, another bplist encoded payload containing the following fields:</p>
<ul>
<li>MCNearbyServiceInviteIDKey: the invite key received with the server InviteResponse.</li>
<li>MCNearbyServiceMessageIDKey: an incremental integer being InviteResponse.MCNearbyServiceMessageIDKey + 1.</li>
<li>MCNearbyServiceRecipientPeerIDKey: client peer id encoded as previously described.</li>
<li>MCNearbyServiceSenderPeerIDKey: server peer id encoded as previously described.</li>
<li>MCNearbyServiceConnectionDataKey: connection data as bplist (again, a bplist inside a bplist ‚Ä¶), described next.</li>
</ul>
<p>The interesting part here is the MCNearbyServiceConnectionDataKey field, which contains a bplist encoded <a target="_blank" rel="noopener" href="https://github.com/evilsocket/mpcfw/blob/main/mpc/tcp/messages.py#L550">binary payload</a> made of:</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://github.com/evilsocket/mpcfw/blob/main/mpc/tcp/messages.py#L383">A header</a> composed of:<ul>
<li>1 signature byte (0x80).</li>
<li>1 byte bitmask of security flags indicating if encryption is enabled (not in this case, LOL).</li>
<li>2 bytes indicating the total size of the payload.</li>
<li>1 byte indicating the number of segments / entries in the payload.</li>
</ul>
</li>
<li>A list of IPv4 and IPv6 addresses, one for each network interface of both peers.</li>
<li>A variable number of <a target="_blank" rel="noopener" href="https://github.com/evilsocket/mpcfw/blob/main/mpc/tcp/messages.py#L474">segments describing each network interface of both peers</a>, made of:<ul>
<li>1 signature byte (0x61).</li>
<li>4 bytes of the numeric peer id (either the client or the server one) trimmed down to 32bits.</li>
<li>4 bytes of a random identifier, my guess is that this creates a new unique identifier together with the previous field.</li>
<li>1 byte indicating the interface type ( ipv4=0x5A ipv6=0x0A ).</li>
<li>3 bytes of padding.</li>
<li>1 byte containing the interface IP index bit-masked with its type.</li>
<li>2 bytes containing an UDP port.</li>
</ul>
</li>
</ol>
<p>Since the application specific part of the protocol works on UDP, by exchanging this data both endpoints become aware of on which possible IP and UDP ports the next part of the communication can happen. </p>
<h3 id="STUN-a-la-Facetime"><a href="#STUN-a-la-Facetime" class="headerlink" title="STUN a la Facetime"></a>STUN a la Facetime</h3><p>After the previous step, an Apple custom implementation of <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/STUN">STUN</a> is used to determine NAT type and which IP:PORT pair is best suited for the communication. Interestingly, while digging hard into this rabbit hole and reversing other frameworks that were referenced here and there, I found out this is the same exact mechanism that Apple Facetime also uses.</p>
<p>I‚Äôve implemented a very basic <a target="_blank" rel="noopener" href="https://github.com/evilsocket/mpcfw/blob/main/mpc/stun/server.py#L13">STUN processor here</a>, what happens is:</p>
<ol>
<li>The server will pick one of the IP:UDP_PORT pairs sent in the ClientData and sends a STUN <a target="_blank" rel="noopener" href="https://github.com/evilsocket/mpcfw/blob/main/mpc/stun/messages.py#L250">Binding Request</a> containing these STUN attributes:<ul>
<li>USERNAME: containing the server and client integer peer identifiers.</li>
<li>ADDRESS_ERROR_CODE: always 0x6.</li>
<li>ALTERNATE_DOMAIN: always 0x03f2.</li>
<li>APPLE_NTP_DELAY: you would see this labled as ICMP by Wireshark, however Apple is using this specific attribute identifier to indicate the NTP delay, as I found out by Ghidra-ing the s*it out of it :D</li>
<li>ICE_CONTROLLING: randomly generate STUN tie breaker / session id.</li>
</ul>
</li>
<li>The client will respond with its own Binding Request, replacing ICE_CONTROLLING with ICE_CONTROLLED and its tie breaker.</li>
<li>The server will send a Binding Response with a MAPPED-ADDRESS attribute indicating the final IP:UDP_PORT pair for the communication.</li>
<li>The client will send its own Binding Response with its UDP MAPPED-ADDRESS.</li>
</ol>
<p>From this point on, an UDP connection is established between the two MAPPED-ADDRESSes and application specific data is exchanged.</p>
<h3 id="Brief-note-on-OSPF"><a href="#Brief-note-on-OSPF" class="headerlink" title="Brief note on OSPF"></a>Brief note on OSPF</h3><p>Despite the Logic Pro specific protocol happening after all these steps is out of the scope of this post, I want to briefly mention how it works.</p>
<p>Interestingly, this protocol is referenced as OSPF from the framework:</p>
<p><img src="/images/2022/ospf.png" alt="ospf?"></p>
<p>Howver it has almost nothing in common with the <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Open_Shortest_Path_First">Open Shortest Path First</a> protocol. Despite some of these function names reference valid OSPF messages such as LSA, LSAACK and so on, the Apple implementation is entirely different.</p>
<p>You can find a partial <a target="_blank" rel="noopener" href="https://github.com/evilsocket/mpcfw/blob/main/mpc/ospf/session.py">python implementation here</a> that will be used after the previous step in order to correctly start the ‚ÄúOSPF‚Äù session and start receiving data from the server. </p>
<p>In this case, each packet is made of <a target="_blank" rel="noopener" href="https://github.com/evilsocket/mpcfw/blob/main/mpc/ospf/messages.py#L11">this header</a>:</p>
<ul>
<li>1 byte of protocol type signature (0xc1).</li>
<li>1 byte of packet type signature.</li>
<li>2 bytes of packet size.</li>
<li>2 bytes indicating OSPF channel, mostly unused.</li>
<li>2 bytes with the packet CRC16/ARC checksum (again, <a target="_blank" rel="noopener" href="https://github.com/evilsocket/mpcfw/blob/main/mpc/utils.py#L10">bruteforcing</a> the type of checksum helped a lot).</li>
<li>4 bytes of the sender peer id.</li>
<li>4 bytes of the receiver peer id.</li>
</ul>
<p>Following, the packet specific payload. </p>
<p>You can find the definitions of some of <a target="_blank" rel="noopener" href="https://github.com/evilsocket/mpcfw/blob/main/mpc/ospf/messages.py">the Logic Pro packets here</a> and the OSPF server code that will initialize the session and start <a target="_blank" rel="noopener" href="https://github.com/evilsocket/mpcfw/blob/main/mpc/ospf/session.py">getting server updates here</a>.</p>
<h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h3><p>This has definitely been a fun ride during which I‚Äôve learned a lot of new stuff about how Apple frameworks handle network communications. I want to reiterate my gratitude to <a target="_blank" rel="noopener" href="https://twitter.com/nabla_c0d3">Alban Diquet</a> for his research and to <a target="_blank" rel="noopener" href="https://twitter.com/isComputerOn">@isComputerOn</a> for pointing me to the right direction when I was about to give up on what it seemed something entirely irrelevant, thanks you so much guys! &lt;3</p>
<p>I also want to comment on something i‚Äôve heard during a talk presented at the last <a target="_blank" rel="noopener" href="https://twitter.com/0x41con">0x41 conference</a>.<br>The researcher who was presenting and who specialized in fuzzing Apple products, mentioned how at the beginning of his path, someone who‚Äôs highly respected and recognized in the infosec community and industry, told him that ‚Äúfuzzing Apple‚Äôs network protocols was a dumb idea‚Äù, which unfortunately convinced the researcher to look elsewhere. </p>
<p>Well, my highly respected and recognized dude, I can tell you it is <strong>not</strong> a dumb idea, <strong>at all</strong>, there‚Äôs <strong>a lot</strong> of unexplored attack surface there. What was dumb, very close-minded and ignorant, is your take about it.</p>
<p>Anyways ‚Ä¶ <a target="_blank" rel="noopener" href="https://github.com/evilsocket/mpcfw">you can find the project on my github</a> as usual, enjoy!</p>

  </div>
  <a target="_blank" rel="noopener" href="https://www.patreon.com/bePatron?u=6065463" data-patreon-widget-type="become-patron-button">Become a Patron!</a><script async src="https://c6.patreon.com/becomePatronButton.bundle.js"></script>
  <br/>
</article>

    <div class="blog-post-comments">
        <div id="disqus_thread">
            <noscript>Please enable JavaScript to view the comments.</noscript>
        </div>
    </div>



    </div>
    
      <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">~/</a></li>
         
          <li><a href="/atom.xml">rss</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#MultipeerConnectivity-Framework"><span class="toc-number">1.</span> <span class="toc-text">MultipeerConnectivity Framework</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Discovery-Phase-Multicast-DNS"><span class="toc-number">2.</span> <span class="toc-text">Discovery Phase: Multicast DNS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#How-a-PeerID-is-made"><span class="toc-number">3.</span> <span class="toc-text">How a PeerID is made</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Handshake-Phase-Hellos-and-Acks"><span class="toc-number">4.</span> <span class="toc-text">Handshake Phase: Hellos and Acks</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Authorization-Phase-Spoofable-Invites-and-BPlist-inside-BPlist-inside-TCP"><span class="toc-number">5.</span> <span class="toc-text">Authorization Phase: Spoofable Invites and BPlist inside BPlist inside TCP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Data-Exchange-Phase"><span class="toc-number">6.</span> <span class="toc-text">Data Exchange Phase</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#STUN-a-la-Facetime"><span class="toc-number">7.</span> <span class="toc-text">STUN a la Facetime</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Brief-note-on-OSPF"><span class="toc-number">8.</span> <span class="toc-text">Brief note on OSPF</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Conclusion"><span class="toc-number">9.</span> <span class="toc-text">Conclusion</span></a></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://www.evilsocket.net/2022/10/20/Reverse-Engineering-the-Apple-MultiPeer-Connectivity-Framework/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://www.evilsocket.net/2022/10/20/Reverse-Engineering-the-Apple-MultiPeer-Connectivity-Framework/&text=Reverse Engineering the Apple MultiPeer Connectivity Framework"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://www.evilsocket.net/2022/10/20/Reverse-Engineering-the-Apple-MultiPeer-Connectivity-Framework/&title=Reverse Engineering the Apple MultiPeer Connectivity Framework"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://www.evilsocket.net/2022/10/20/Reverse-Engineering-the-Apple-MultiPeer-Connectivity-Framework/&is_video=false&description=Reverse Engineering the Apple MultiPeer Connectivity Framework"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Reverse Engineering the Apple MultiPeer Connectivity Framework&body=Check out this article: https://www.evilsocket.net/2022/10/20/Reverse-Engineering-the-Apple-MultiPeer-Connectivity-Framework/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://www.evilsocket.net/2022/10/20/Reverse-Engineering-the-Apple-MultiPeer-Connectivity-Framework/&title=Reverse Engineering the Apple MultiPeer Connectivity Framework"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://www.evilsocket.net/2022/10/20/Reverse-Engineering-the-Apple-MultiPeer-Connectivity-Framework/&title=Reverse Engineering the Apple MultiPeer Connectivity Framework"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://www.evilsocket.net/2022/10/20/Reverse-Engineering-the-Apple-MultiPeer-Connectivity-Framework/&title=Reverse Engineering the Apple MultiPeer Connectivity Framework"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://www.evilsocket.net/2022/10/20/Reverse-Engineering-the-Apple-MultiPeer-Connectivity-Framework/&title=Reverse Engineering the Apple MultiPeer Connectivity Framework"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://www.evilsocket.net/2022/10/20/Reverse-Engineering-the-Apple-MultiPeer-Connectivity-Framework/&name=Reverse Engineering the Apple MultiPeer Connectivity Framework&description=&lt;p&gt;Some time ago I was using &lt;a href=&#34;https://www.apple.com/it/logic-pro/&#34;&gt;Logic Pro&lt;/a&gt; to record some of my music and I needed a way to start and stop the recording from an iPhone, so I found about &lt;a href=&#34;https://apps.apple.com/it/app/logic-remote/id638394624&#34;&gt;Logic Remote&lt;/a&gt; and was quite happy with it.&lt;br&gt;After the session, the hacker in me became curious about how the tools were communicating with each other, so I quickly started Wireshark while establishing a connection and saw something that tickled my curiosity even more: some of the data, such as the client and server names, were transmitted in cleartext on what it seemed a custom (and as typical of Apple, undocumented) TCP protocol (&lt;strong&gt;‚Äústevie‚Äù&lt;/strong&gt; being the hostname of my Mac):&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/2022/cleartext.png&#34; alt=&#34;cleartext packets&#34;&gt;&lt;/p&gt;
&lt;p&gt;Using &lt;a href=&#34;https://ss64.com/osx/lsof.html&#34;&gt;lsof&lt;/a&gt; confirmed that this was indeed the communication between the client phone and Logic listening on port 56076:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/2022/lsof.png&#34; alt=&#34;lsof&#34;&gt;&lt;/p&gt;
&lt;p&gt;Initially I tought this was just some Logic Pro specific protocol and very lazily started looking into it, without much success mostly due to lack of motivation given the very limited scope of the research. After a while I &lt;a href=&#34;https://twitter.com/evilsocket/status/1568310905640722433&#34;&gt;tweeted&lt;/a&gt; asking if anyone had ever seen anything like it. &lt;a href=&#34;https://twitter.com/isComputerOn/status/1568344165175508992&#34;&gt;@isComputerOn pointed out&lt;/a&gt; that this looked a lot like a protocol that has been partially reversed and presented by &lt;a href=&#34;https://twitter.com/nabla_c0d3&#34;&gt;Alban Diquet&lt;/a&gt; back in 2014. Unfortunately, however brilliant, this research covers the protocol at a very high level and doesn‚Äôt really document the packets, their fields and how to establish a connection from anything but a client using the Apple framework. However, this helped me a lot in two ways: first it helped me realize this was not just Logic Pro specific, but that it was part of the &lt;a href=&#34;https://developer.apple.com/documentation/multipeerconnectivity&#34;&gt;Multipeer Connectivity Framework&lt;/a&gt;, and gave me a few hints about the general logic of the protocol itself.&lt;/p&gt;
&lt;p&gt;With renewed curiosity and motivation then I jumped into this rabbit hole and managed to reverse engineer all network packets. This allowed me to write a &lt;a href=&#34;https://github.com/evilsocket/mpcfw&#34;&gt;Python proof of concept client&lt;/a&gt; that automatically discovers any MPC servers, initializes the connection and succesfully exchanges application specific data packets.&lt;/p&gt;
&lt;p&gt;Moreover, while sending crafted packets and attempting all sorts of things, &lt;strong&gt;I‚Äôve discovered several vulnerabilities in the Apple custom made parsers&lt;/strong&gt;. I will &lt;strong&gt;not&lt;/strong&gt; discuss them here (exception made for the session spoofing) but at the same time I‚Äôm not interested in reporting them to Apple, I‚Äôve heard way too many negative stories about their disclosure program and in general how they mistreat researchers.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/2022/crash.png&#34; alt=&#34;crash&#34;&gt;&lt;/p&gt;
&lt;p&gt;Let‚Äôs see how this whole thing works! :)&lt;/p&gt;"><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

    
    <footer id="footer">
  <div class="footer-left">
    Copyright &copy; 2023 Simone Margaritelli
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">~/</a></li>
         
          <li><a href="/atom.xml">rss</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

</body>
</html>
<!-- styles -->

<link rel="stylesheet" href="/lib/font-awesome/css/fontawesome-all.min.css">


<link rel="stylesheet" href="/lib/justified-gallery/css/justifiedGallery.min.css">


<!-- jquery -->

<script src="/lib/jquery/jquery.min.js"></script>


<script src="/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

    <script type="text/javascript">
        (function(i,s,o,g,r,a,m) {i['GoogleAnalyticsObject']=r;i[r]=i[r]||function() {
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
        ga('create', 'UA-22026549-1', 'auto');
        ga('send', 'pageview');
    </script>

<!-- Baidu Analytics -->

<!-- Disqus Comments -->

    <script type="text/javascript">
        var disqus_shortname = 'evilsocket';

        (function(){
            var dsq = document.createElement('script');
            dsq.type = 'text/javascript';
            dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        }());
    </script>


<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-4da572964da15ce9" async="async"></script>

