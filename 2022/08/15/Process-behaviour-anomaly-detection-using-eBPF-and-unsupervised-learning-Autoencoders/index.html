<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="X-UA-Compatible" content="IE=edge">

<title>Process Behaviour Anomaly Detection Using eBPF and Unsupervised-Learning Autoencoders | evilsocket</title>
<meta name="description" content="">


  <link rel="alternate" href="/atom.xml" title="evilsocket" type="application/atom+xml">


<link rel="icon" href="/images/favicon.ico">

<!-- Open Graph -->
<meta property="og:type" content="article">
<meta property="og:title" content="Process Behaviour Anomaly Detection Using eBPF and Unsupervised-Learning Autoencoders">
<meta property="og:description" content="">
<meta property="og:url" content="/2022/08/15/Process-behaviour-anomaly-detection-using-eBPF-and-unsupervised-learning-Autoencoders/">
<meta property="og:site_name" content="evilsocket">

  
  
    <meta property="og:image" content="https://i.imgur.com/QEmpeDl.jpg">
  


<!-- Twitter Card -->
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="Process Behaviour Anomaly Detection Using eBPF and Unsupervised-Learning Autoencoders">
<meta name="twitter:description" content="">

<!-- Schema.org JSON-LD -->


<script type="application/ld+json">
{"@context":"https://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.evilsocket.net/2022/08/15/Process-behaviour-anomaly-detection-using-eBPF-and-unsupervised-learning-Autoencoders/"},"headline":"Process Behaviour Anomaly Detection Using eBPF and Unsupervised-Learning Autoencoders","description":"","image":"https://www.evilsocket.nethttps://i.imgur.com/QEmpeDl.jpg","datePublished":"2022-08-15T14:06:05.000Z","dateModified":"2025-12-19T18:35:53.165Z","author":{"@type":"Person","name":"Simone Margaritelli","description":"Italian cybersecurity researcher and open-source developer","url":"https://www.evilsocket.net","sameAs":["https://github.com/evilsocket","https://twitter.com/evilsocket","http://it.linkedin.com/in/simonemargaritelli/"],"jobTitle":"Security Researcher","worksFor":{"@type":"Organization","name":"Independent"}},"publisher":{"@type":"Organization","name":"evilsocket","url":"https://www.evilsocket.net","logo":{"@type":"ImageObject","url":"https://www.evilsocket.net/images/glider.png"}},"keywords":"linux, linux security, defensive security, ai, tensorflow, deep learning, dnn, machine learning, neural networks, deep neural networks, artificial intelligence, ebpf, sys_enter, raw_syscalls, tracepoint, kprobe, kretprobe, bcc, unsupervised learning, autoencoder, process behaviour, anomaly detection, process anomaly detection, syscall tracing, runtime protection","articleSection":"Technology","inLanguage":"en"}
</script>


<!-- Fonts -->
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

<!-- Styles -->
<link rel="stylesheet" href="/css/style.css">


<!-- Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-22026549-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-22026549-1');
</script>


<meta name="generator" content="Hexo 5.4.2"></head>
<body class="post-page">
  <header class="site-header">
  <div class="header-inner">
    <div class="site-branding">
      <a href="/" class="site-logo">
        
          <img src="/images/glider.png" alt="evilsocket" width="50" height="50">
        
        <div class="site-title-group">
          <span class="site-title">evilsocket</span>
          <span class="site-motto">Preoccupied with a single leaf, you won't see the tree. Preoccupied with a single tree... you'll miss the entire forest.</span>
        </div>
      </a>
    </div>
    
    <nav class="site-nav">
      
        <a href="/" class="nav-link">
          HOME
        </a>
      
        <a href="/atom.xml" class="nav-link">
          RSS
        </a>
      
    </nav>
  </div>
</header>

  
  <main class="main-content">
    <article class="post-full">
  <header class="post-header">
    <h1 class="post-title">Process Behaviour Anomaly Detection Using eBPF and Unsupervised-Learning Autoencoders</h1>
    <div class="post-meta">
      BY <span class="post-author">Simone Margaritelli</span>
      — <time datetime="2022-08-15T14:06:05.000Z">15 Aug 2022</time>
      
        — <a href="/tags/linux/" class="post-category">linux</a>, <a href="/tags/linux-security/" class="post-category">linux security</a>, <a href="/tags/defensive-security/" class="post-category">defensive security</a>, <a href="/tags/ai/" class="post-category">ai</a>, <a href="/tags/tensorflow/" class="post-category">tensorflow</a>, <a href="/tags/deep-learning/" class="post-category">deep learning</a>, <a href="/tags/dnn/" class="post-category">dnn</a>, <a href="/tags/machine-learning/" class="post-category">machine learning</a>, <a href="/tags/neural-networks/" class="post-category">neural networks</a>, <a href="/tags/deep-neural-networks/" class="post-category">deep neural networks</a>, <a href="/tags/artificial-intelligence/" class="post-category">artificial intelligence</a>, <a href="/tags/ebpf/" class="post-category">ebpf</a>, <a href="/tags/sys-enter/" class="post-category">sys_enter</a>, <a href="/tags/raw-syscalls/" class="post-category">raw_syscalls</a>, <a href="/tags/tracepoint/" class="post-category">tracepoint</a>, <a href="/tags/kprobe/" class="post-category">kprobe</a>, <a href="/tags/kretprobe/" class="post-category">kretprobe</a>, <a href="/tags/bcc/" class="post-category">bcc</a>, <a href="/tags/unsupervised-learning/" class="post-category">unsupervised learning</a>, <a href="/tags/autoencoder/" class="post-category">autoencoder</a>, <a href="/tags/process-behaviour/" class="post-category">process behaviour</a>, <a href="/tags/anomaly-detection/" class="post-category">anomaly detection</a>, <a href="/tags/process-anomaly-detection/" class="post-category">process anomaly detection</a>, <a href="/tags/syscall-tracing/" class="post-category">syscall tracing</a>, <a href="/tags/runtime-protection/" class="post-category">runtime protection</a>
      
    </div>
  </header>

  <div class="post-content">
    <p>Hello everybody, I hope you’ve been enjoying this summer after two years of Covid and lockdowns :D In this post I’m going to describe how to use eBPF syscall tracing in a creative way in order to detect process behaviour anomalies at runtime using an unsupervised learning model called autoencoder. </p>
<p><img src="https://i.imgur.com/QEmpeDl.jpg" alt="anomalies"></p>
<p>While many projects approach this problem by building a list of allowed system calls and checking at runtime if the process is using anything outside of this list, we’ll use a methodology that will not only save us from explicitly compiling this list, but will also take into account how fast the process is using system calls that would normally be allowed but only within a certain range of usage per second. This techique can potentially detect process exploitation, denial-of-service and several other types of attacks.</p>
<p><strong>You’ll find the <a target="_blank" rel="noopener" href="https://github.com/evilsocket/ebpf-process-anomaly-detection">complete source code on my Github</a> as usual.</strong></p>
<h2 id="What-is-eBPF"><a href="#What-is-eBPF" class="headerlink" title="What is eBPF?"></a>What is eBPF?</h2><p><a target="_blank" rel="noopener" href="https://ebpf.io/">eBPF</a> is a technology that allows to intercept several aspect of the Linux kernel runtime without using a kernel module. At its core eBPF is a virtual machine running inside the kernel that performs sanity checks on an eBPF program opcodes before loading it in order to ensure runtime safety.</p>
<p>From the <a target="_blank" rel="noopener" href="https://ebpf.io/what-is-ebpf">eBPF.io</a> page:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eBPF (which is no longer an acronym for anything) is a revolutionary technology with origins in the Linux kernel that can run sandboxed programs in a privileged context such as the operating system kernel. It is used to safely and efficiently extend the capabilities of the kernel without requiring to change kernel source code or load kernel modules.  </span><br><span class="line"></span><br><span class="line">Historically, the operating system has always been an ideal place to implement observability, security, and networking functionality due to the kernel’s privileged ability to oversee and control the entire system. At the same time, an operating system kernel is hard to evolve due to its central role and high requirement towards stability and security. The rate of innovation at the operating system level has thus traditionally been lower compared to functionality implemented outside of the operating system.</span><br></pre></td></tr></table></figure>

<p><img src="https://i.imgur.com/8yG0Nyr.png" alt="ebpf"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eBPF changes this formula fundamentally. By allowing to run sandboxed programs within the operating system, application developers can run eBPF programs to add additional capabilities to the operating system at runtime. The operating system then guarantees safety and execution efficiency as if natively compiled with the aid of a Just-In-Time (JIT) compiler and verification engine. This has led to a wave of eBPF-based projects covering a wide array of use cases, including next-generation networking, observability, and security functionality.</span><br></pre></td></tr></table></figure>

<p>There are several options to compile into bytecode and then run eBPF programs, such as <a target="_blank" rel="noopener" href="https://github.com/cilium/ebpf">Cilium Golang eBPF package</a>, <a target="_blank" rel="noopener" href="https://github.com/aya-rs/aya">Aya Rust crate</a> and <a target="_blank" rel="noopener" href="https://github.com/iovisor/bcc">IOVisor Python BCC package</a> and many more. BCC being the simplest is the one we’re going to use for this post. Keep in mind that the same exact things can be done with all these libraries and only runtime dependencies and performance would change.</p>
<h3 id="System-call-Tracing-with-eBPF"><a href="#System-call-Tracing-with-eBPF" class="headerlink" title="System call Tracing with eBPF"></a>System call Tracing with eBPF</h3><p>The usual approach to trace system calls with eBPF consists in creating a <a target="_blank" rel="noopener" href="https://github.com/iovisor/bcc/blob/master/docs/reference_guide.md#3-tracepoints">tracepoint</a> or a <a target="_blank" rel="noopener" href="https://github.com/iovisor/bcc/blob/master/docs/reference_guide.md#1-kprobes">kprobe</a> on each system call we want to intercept, somehow fetch the arguments of the call and then report each one individually to user space using either a <a target="_blank" rel="noopener" href="https://github.com/iovisor/bcc/blob/master/docs/reference_guide.md#2-bpf_perf_output">perf buffer</a> or a <a target="_blank" rel="noopener" href="https://github.com/iovisor/bcc/blob/master/docs/reference_guide.md#5-bpf_ringbuf_output">ring buffer</a>. While this method is great to track each system call individually and check their arguments (for instance, checking which files are being accessed or which hosts the program is connecting to), it has a couple of issues. </p>
<p>First, reading the arguments for each syscall is quite tricky depending on the system architecture and kernel compilation flags. For instance in some cases it’s not possible to read the arguments while entering the syscall, but only once the syscall has been executed, by saving pointers from a kprobe and then reading them from a kretprobe. Another important issue is the eBPF buffers throughput: when the target process is executing a lot of system calls in a short period of time (think about an HTTP server under heavy stress, or a process performing a lot of I/O), <a target="_blank" rel="noopener" href="http://blog.itaysk.com/2020/04/20/ebpf-lost-events">events can be lost</a> making this approach less than ideal.</p>
<h3 id="Poor-man’s-Approach"><a href="#Poor-man’s-Approach" class="headerlink" title="Poor man’s Approach"></a>Poor man’s Approach</h3><p><img src="https://i.imgur.com/vuHfl1n.jpg" alt="kiss"></p>
<p>Since we’re not interested in the system calls arguments, we’re going to use an alternative approach that doesn’t have the aforementioned issues. The main idea is very very simple: we’re going to have a single tracepoint on the <code>sys_enter</code> event, triggered every time <strong>any</strong> system call is executed. Instead of immediately reporting the call to userspace via a buffer, we’re only going to increment the relative integer slot in an array, creating an histogram.</p>
<p>This array is 512 integers long (512 set as a constant maximum number of system calls), so that after (for instance) system call <code>read</code> (number 0) is executed twice and <code>mprotect</code> (number 10) once, we’ll have a vector/histogram that’ll look like this:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2,0,0,0,0,0,0,0,0,0,1,0,0,0,..........</span><br></pre></td></tr></table></figure>

<p>The relative eBPF is very simple and looks like this:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// defines a per-cpu array in order to avoid race coinditions while updating the histogram</span></span><br><span class="line">BPF_PERCPU_ARRAY(histogram, u32, MAX_SYSCALLS);</span><br><span class="line"></span><br><span class="line"><span class="comment">// here&#x27;s our tracepoint on sys_enter</span></span><br><span class="line">TRACEPOINT_PROBE(raw_syscalls, sys_enter)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// filter by target pid and return if this activity belongs to a process we&#x27;re not interested in</span></span><br><span class="line">    u64 pid = bpf_get_current_pid_tgid() &gt;&gt; <span class="number">32</span>;</span><br><span class="line">    <span class="keyword">if</span>(pid != TARGET_PID) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// populate the histogram, args-&gt;id contains the system call number</span></span><br><span class="line">    u32 key = (u32)args-&gt;id;</span><br><span class="line">    u32 value = <span class="number">0</span>, *pval = <span class="literal">NULL</span>;</span><br><span class="line">    pval = histogram.lookup_or_try_init(&amp;key, &amp;value);</span><br><span class="line">    <span class="keyword">if</span>(pval) &#123;</span><br><span class="line">        *pval += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>So far no transfer of data to user space is performed, so no system call invocation is lost and everything is accounted for in this histogram. </p>
<p>We’ll then perform a simple polling of this vector from userspace every 100 milliseconds and, by comparing the vector to its previous state, we’ll calculate the rate of change for every system call:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># polling loop</span></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    <span class="comment"># get single histogram from per-cpu arrays</span></span><br><span class="line">    histogram = [histo_map[s] <span class="keyword">for</span> s <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, MAX_SYSCALLS)]</span><br><span class="line">    <span class="comment"># if any change happened</span></span><br><span class="line">    <span class="keyword">if</span> histogram != prev:</span><br><span class="line">        <span class="comment"># compute the rate of change for every syscall</span></span><br><span class="line">        deltas = [ <span class="number">1.0</span> - (prev[s] / histogram[s]) <span class="keyword">if</span> histogram[s] != <span class="number">0.0</span> <span class="keyword">else</span> <span class="number">0.0</span> <span class="keyword">for</span> s <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, MAX_SYSCALLS)]</span><br><span class="line">        prev = histogram</span><br><span class="line"></span><br><span class="line">    <span class="comment"># ... SNIPPET ...</span></span><br><span class="line"></span><br><span class="line">    time.sleep(args.time / <span class="number">1000.0</span>)</span><br></pre></td></tr></table></figure>

<p>This will not only take into account which system calls are executed (and the ones that are not executed, thus having counter always to 0), but also how fast they are executed during normal activity in a given amount of time.</p>
<p>Once we have this data saved to a CSV file, we can then train a model that’ll be able to detect anomalies at runtime.</p>
<h2 id="Anomaly-detection-with-Autoencoders"><a href="#Anomaly-detection-with-Autoencoders" class="headerlink" title="Anomaly detection with Autoencoders"></a>Anomaly detection with Autoencoders</h2><p>An <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Autoencoder">autoencoder</a> is an artificial neural network used in unsupervised learning tasks, able to create an internal representation of unlabeled data (therefore the “unsupervised”) and produce an output of the same size. This approach can be used for data compression (as the internal encoding layer is usually smaller than the input) and of course anomaly detection like in our case.</p>
<p><img src="https://i.imgur.com/jsWJbIx.png" alt="autoencoder"></p>
<center><small>Source: https://lilianweng.github.io/posts/2018-08-12-vae/</small></center>

<p>The main idea is to train the model and using our CSV dataset both as the input to the network and as its desired output. This way the ANN will learn what is “normal” in the dataset by correctly reconstructing each vector. When the output vector is substantially different from the input vector, we will know this is an anomaly because the ANN was not trained to reconstruct this specific one, meaning it was outside of what we consider normal activity.</p>
<p>Our autoencoder has 512 inputs (defined as the <code>MAX_SYSCALLS</code> constant) and the same number of outputs, while the internal representation layer is half that size:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">n_inputs = MAX_SYSCALLS</span><br><span class="line"></span><br><span class="line"><span class="comment"># input layer</span></span><br><span class="line">inp = Input(shape=(n_inputs,))</span><br><span class="line"><span class="comment"># encoder layer</span></span><br><span class="line">encoder = Dense(n_inputs)(inp)</span><br><span class="line">encoder = ReLU()(encoder)</span><br><span class="line"><span class="comment"># internal representation layer</span></span><br><span class="line">middle = Dense(<span class="built_in">int</span>(n_inputs / <span class="number">2</span>))(encoder)</span><br><span class="line"><span class="comment"># decoder layer</span></span><br><span class="line">decoder = Dense(n_inputs)(middle)</span><br><span class="line">decoder = ReLU()(decoder)</span><br><span class="line">decoder = Dense(n_inputs, activation=<span class="string">&#x27;linear&#x27;</span>)(decoder)</span><br><span class="line">m = Model(inp, decoder)</span><br><span class="line"></span><br><span class="line"><span class="comment"># we use mean square error as the loss function as we&#x27;re interested in the reconstruction error</span></span><br><span class="line">m.<span class="built_in">compile</span>(optimizer=<span class="string">&#x27;adam&#x27;</span>, loss=<span class="string">&#x27;mse&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>For training our CSV dataset is split in training data and testing/validation data. After training the latter is used to compute the maximum reconstruction error the model presents for “normal” data:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># test the model on test data to calculate the error threshold</span></span><br><span class="line">y_test = model.predict(test)</span><br><span class="line">test_err = []</span><br><span class="line"><span class="comment"># for each vector</span></span><br><span class="line"><span class="keyword">for</span> ind <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(test)):</span><br><span class="line">    <span class="comment"># get the absolute error as a difference of the input and reconstructed output</span></span><br><span class="line">    abs_err = np.<span class="built_in">abs</span>(test[ind, :]-y_test[ind, :])</span><br><span class="line">    <span class="comment"># append the sum of each individual error</span></span><br><span class="line">    test_err.append(abs_err.<span class="built_in">sum</span>())</span><br><span class="line"><span class="comment"># the threshold will be the maximum cumulative error we&#x27;ve found</span></span><br><span class="line">threshold = <span class="built_in">max</span>(test_err)</span><br></pre></td></tr></table></figure>

<p>We now have an autoencoder and its reference error threshold that we can use to perform live anomaly detection.</p>
<h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><p>Let’s see the program in action. For this example I decided to monitor the <code>Spotify</code> process on Linux. Due to its high I/O intensity Spotify represents a nice candidate for a demo of this approach. I captured training data while streaming some music and clicking around playlists and settings. One thing I did <strong>not</strong> do during the learning stage is clicking on the <code>Connect with Facebook</code> button, this will be our test. Since this action triggers system calls that are not usually executed by Spotify, we can use it to check if our model is actually detecting anomalies at runtime.</p>
<h3 id="Learning-from-a-live-process"><a href="#Learning-from-a-live-process" class="headerlink" title="Learning from a live process"></a>Learning from a live process</h3><p>Let’s say that Spotify has process id 1234, we’ll start by capturing some live data while using it:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ./main.py --pid 1234 --data spotify.csv --learn</span><br></pre></td></tr></table></figure>

<p>Keep this running for as much as you can, having the biggest amount of samples possible is key in order for our model to be accurate in detecting anomalies. Once you’re happy with the amount of samples, you can stop the learning step by pressing Ctrl+C. </p>
<p>Your  <code>spotify.csv</code> dataset is now ready to be used for training.</p>
<h3 id="Training-the-model"><a href="#Training-the-model" class="headerlink" title="Training the model"></a>Training the model</h3><p>We’ll now train the model for 200 epochs, you will see the validation loss (the mean square error of the reconstructed vector) decreasing at each step, indicating that the model is indeed learning from the data:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./main.py --data spotify.csv --epochs 200 --model spotify.h5 --train</span><br></pre></td></tr></table></figure>

<p>After the training is completed, the model will be saved to the <code>spotify.h5</code> file and the reference error threshold will be printed on screen:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">Epoch 195&#x2F;200</span><br><span class="line">60&#x2F;60 [&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;] - 0s 2ms&#x2F;step - loss: 1.3071e-05 - val_loss: 6.3671e-05</span><br><span class="line">Epoch 196&#x2F;200</span><br><span class="line">60&#x2F;60 [&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;] - 0s 2ms&#x2F;step - loss: 1.8221e-05 - val_loss: 5.2383e-05</span><br><span class="line">Epoch 197&#x2F;200</span><br><span class="line">60&#x2F;60 [&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;] - 0s 2ms&#x2F;step - loss: 9.2132e-06 - val_loss: 5.3354e-05</span><br><span class="line">Epoch 198&#x2F;200</span><br><span class="line">60&#x2F;60 [&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;] - 0s 2ms&#x2F;step - loss: 9.2722e-06 - val_loss: 4.9380e-05</span><br><span class="line">Epoch 199&#x2F;200</span><br><span class="line">60&#x2F;60 [&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;] - 0s 2ms&#x2F;step - loss: 8.0692e-06 - val_loss: 5.1954e-05</span><br><span class="line">Epoch 200&#x2F;200</span><br><span class="line">60&#x2F;60 [&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;] - 0s 2ms&#x2F;step - loss: 8.3448e-06 - val_loss: 5.0102e-05</span><br><span class="line">model saved to spotify.h5, getting error threshold for 106 samples ...</span><br><span class="line"></span><br><span class="line">error threshold&#x3D;9.969912</span><br></pre></td></tr></table></figure>

<h3 id="Detecting-anomalies"><a href="#Detecting-anomalies" class="headerlink" title="Detecting anomalies"></a>Detecting anomalies</h3><p>Once the model has been trained it can be used on the live target process to detect anomalies, in this case we’re using a 10.0 error threshold:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ./main.py --pid 1234 --model spotify.h5 --max-error 10.0 --run</span><br></pre></td></tr></table></figure>

<p>When an anomaly is detected the cumulative error will be printed along wiht the top 3 anomalous system calls and their respective error. </p>
<p>In this example, I’m clicking on the <code>Connect with Facebook</code> button that will use system calls such as <code>getpriority</code> that were previsouly unseen in training data. </p>
<p>We can see from the output that the model is indeed detecting anomalies:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">error &#x3D; 30.605255 - max &#x3D; 10.000000 - top 3:</span><br><span class="line">  b&#39;getpriority&#39; &#x3D; 0.994272</span><br><span class="line">  b&#39;writev&#39; &#x3D; 0.987554</span><br><span class="line">  b&#39;creat&#39; &#x3D; 0.969955</span><br></pre></td></tr></table></figure>

<p><img src="https://i.imgur.com/sW1gUJ5.jpg" alt="success"></p>
<h2 id="Conclusions"><a href="#Conclusions" class="headerlink" title="Conclusions"></a>Conclusions</h2><p>This post shows how by using a relatively simple approach and giving up some of the system call speficics (the arguments) we can overcome performance issues and still be able to capture enough information to perform anomaly detection. As previously said this approach works for several scenarios, from simple anomalous behaviour due to bugs, to denial of service attacks, bruteforcing and exploitation of the target process. </p>
<p>The overall performance of the system could be improved by using native libraries such as <a target="_blank" rel="noopener" href="https://github.com/aya-rs/aya">Aya</a> and its accuracy with some hyper parameters tuning of the model along with more granular per-feature error thresholds. </p>
<p>All these things are left as an exercise for the reader :D</p>
<p><img src="https://i.imgur.com/TNrJE1N.jpg" alt="lol"></p>

  </div>

  
    <div class="post-tags">
      
        <a href="/tags/linux/" class="tag">#linux</a>
      
        <a href="/tags/linux-security/" class="tag">#linux security</a>
      
        <a href="/tags/defensive-security/" class="tag">#defensive security</a>
      
        <a href="/tags/ai/" class="tag">#ai</a>
      
        <a href="/tags/tensorflow/" class="tag">#tensorflow</a>
      
        <a href="/tags/deep-learning/" class="tag">#deep learning</a>
      
        <a href="/tags/dnn/" class="tag">#dnn</a>
      
        <a href="/tags/machine-learning/" class="tag">#machine learning</a>
      
        <a href="/tags/neural-networks/" class="tag">#neural networks</a>
      
        <a href="/tags/deep-neural-networks/" class="tag">#deep neural networks</a>
      
        <a href="/tags/artificial-intelligence/" class="tag">#artificial intelligence</a>
      
        <a href="/tags/ebpf/" class="tag">#ebpf</a>
      
        <a href="/tags/sys-enter/" class="tag">#sys_enter</a>
      
        <a href="/tags/raw-syscalls/" class="tag">#raw_syscalls</a>
      
        <a href="/tags/tracepoint/" class="tag">#tracepoint</a>
      
        <a href="/tags/kprobe/" class="tag">#kprobe</a>
      
        <a href="/tags/kretprobe/" class="tag">#kretprobe</a>
      
        <a href="/tags/bcc/" class="tag">#bcc</a>
      
        <a href="/tags/unsupervised-learning/" class="tag">#unsupervised learning</a>
      
        <a href="/tags/autoencoder/" class="tag">#autoencoder</a>
      
        <a href="/tags/process-behaviour/" class="tag">#process behaviour</a>
      
        <a href="/tags/anomaly-detection/" class="tag">#anomaly detection</a>
      
        <a href="/tags/process-anomaly-detection/" class="tag">#process anomaly detection</a>
      
        <a href="/tags/syscall-tracing/" class="tag">#syscall tracing</a>
      
        <a href="/tags/runtime-protection/" class="tag">#runtime protection</a>
      
    </div>
  

  <nav class="post-navigation">
    
      <a href="/2022/10/20/Reverse-Engineering-the-Apple-MultiPeer-Connectivity-Framework/" class="nav-prev">
        <span class="nav-label">PREVIOUS</span>
        <span class="nav-title">Reverse Engineering the Apple MultiPeer Connectivity Framework</span>
      </a>
    
    
      <a href="/2021/02/13/Hide-your-servers-in-plain-sight-presenting-ShieldWall/" class="nav-next">
        <span class="nav-label">NEXT</span>
        <span class="nav-title">Hide Your Servers in Plain Sight, Presenting ShieldWall</span>
      </a>
    
  </nav>
</article>


  


<section class="related-posts">
  <h3 class="related-title">YOU MIGHT ALSO LIKE...</h3>
  <div class="cards-grid cards-grid-related">
    
      

<article class="card card-light">
  <a href="/2025/12/18/TP-Link-Tapo-C200-Hardcoded-Keys-Buffer-Overflows-and-Privacy-in-the-Era-of-AI-Assisted-Reverse-Engineering/" class="card-link">
    
      <div class="card-image" style="background-image: url('/images/2025/tapo/header.jpg')">
        
      </div>
    
    
    
      <div class="card-content">
        <h2 class="card-title">TP-Link Tapo C200: Hardcoded Keys, Buffer Overflows and Privacy in the Era of AI Assisted Reverse Engineering</h2>
        
        <div class="card-footer">
          <span class="card-read-more">READ MORE</span>
        </div>
      </div>
    
  </a>
</article>

    
      

<article class="card card-overlay">
  <a href="/2025/03/13/How-To-Write-An-Agent/" class="card-link">
    
      <div class="card-image" style="background-image: url('/images/2025/agent/loop.png')">
        
          <div class="card-overlay-content">
            <h2 class="card-title">How to Write an Agent</h2>
            <span class="card-read-more">READ MORE</span>
          </div>
        
      </div>
    
    
    
  </a>
</article>

    
      

<article class="card card-overlay">
  <a href="/2024/09/26/Attacking-UNIX-systems-via-CUPS-Part-I/" class="card-link">
    
      <div class="card-image" style="background-image: url('/images/2024/cups1/smart.jpg')">
        
          <div class="card-overlay-content">
            <h2 class="card-title">Attacking UNIX Systems via CUPS, Part I</h2>
            <span class="card-read-more">READ MORE</span>
          </div>
        
      </div>
    
    
    
  </a>
</article>

    
      

<article class="card card-light">
  <a href="/2021/02/13/Hide-your-servers-in-plain-sight-presenting-ShieldWall/" class="card-link">
    
      <div class="card-image" style="background-image: url('/images/2021/shieldwall_gophers_vikings.jpg')">
        
      </div>
    
    
    
      <div class="card-content">
        <h2 class="card-title">Hide Your Servers in Plain Sight, Presenting ShieldWall</h2>
        
        <div class="card-footer">
          <span class="card-read-more">READ MORE</span>
        </div>
      </div>
    
  </a>
</article>

    
  </div>
</section>




  </main>
  
  <footer class="site-footer">
  <div class="footer-inner">
    <div class="footer-social">
      
        
          
            <a href="https://github.com/evilsocket" class="social-link" target="_blank" rel="noopener" aria-label="GitHub">
              <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/></svg>
            </a>
          
        
          
            <a href="https://twitter.com/evilsocket" class="social-link" target="_blank" rel="noopener" aria-label="Twitter">
              <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor"><path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z"/></svg>
            </a>
          
        
          
            <a href="http://it.linkedin.com/in/simonemargaritelli/" class="social-link" target="_blank" rel="noopener" aria-label="LinkedIn">
              <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor"><path d="M20.447 20.452h-3.554v-5.569c0-1.328-.027-3.037-1.852-3.037-1.853 0-2.136 1.445-2.136 2.939v5.667H9.351V9h3.414v1.561h.046c.477-.9 1.637-1.85 3.37-1.85 3.601 0 4.267 2.37 4.267 5.455v6.286zM5.337 7.433c-1.144 0-2.063-.926-2.063-2.065 0-1.138.92-2.063 2.063-2.063 1.14 0 2.064.925 2.064 2.063 0 1.139-.925 2.065-2.064 2.065zm1.782 13.019H3.555V9h3.564v11.452zM22.225 0H1.771C.792 0 0 .774 0 1.729v20.542C0 23.227.792 24 1.771 24h20.451C23.2 24 24 23.227 24 22.271V1.729C24 .774 23.2 0 22.222 0h.003z"/></svg>
            </a>
          
        
          
        
          
            <a href="mailto:evilsocket@gmail.com" class="social-link" aria-label="Email">
              <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"/><polyline points="22,6 12,13 2,6"/></svg>
            </a>
          
        
      
    </div>
    <p class="footer-copyright">
      &copy; 2025 evilsocket. 
      Powered by <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a>.
    </p>
  </div>
</footer>

  <!-- Minimal JS - no external dependencies needed -->
<script>
  // Lazy load images
  document.addEventListener('DOMContentLoaded', function() {
    var images = document.querySelectorAll('.card-image[data-bg]');
    images.forEach(function(img) {
      img.style.backgroundImage = 'url(' + img.dataset.bg + ')';
    });
  });
</script>

</body>
</html>
